1. Введение
>>>1. Почему NestJS
*03.20 набор возможностей nest.js
*03.25 обладает раширяемой модульной архитектурой
*06:30 архитектура фрэймворка
*09:20 nest позволяет создавать удбные абстракции, благодаря чему можно легко менять одну библиотеку на другую
*10:00 многое библиотеки уже вшиты в nest
>>>2. Как устроен курс
>>>3. Обзор проекта

2. Настройка окружения
>>>1. Настройка окружения
>>>2. Работа NestJS-cli
*0:55 основные команды
*0:55 команда new создание нового проекта
*02:30 автор утверждает что на js (без ts) ничего нормального не сделаешь. Я не согласен, думаю что сложно, но можно.
*2:35 команда generate создание компонента
*04:20 при использовании команды generate можно использовать вложенные пути
*04:30 команда build
*06:20 команда start
*07:10 создание проекта
>>>3. Настройки для VSCode
*0:20 автор, как и автор курса по node предпочитают tab пробелу, потому что так ts-lint. В шторме по умолчанию не так, но пока решил сделать как они (уже передумал). Edito > CodeStyle > TypeScript
*02:10 TSLint deprecated, но по мнению автора у ESLint для TS многого сложных заморочек. ХЗ подумаю.

3. Введение в TypeScript
>>>1. Компилятор TypeScript
*0:10 TS надмножество JS, любой JS будет валидным TS
*1:15 настройка конфигурации
*2:00 простой код
>>>2. Базовые типы
*2:20 тип any не рекомендуется, если переменной не назначить тип, то он будет any, но будет считаться ошибкой. Параметр noImplistyAny отключает ошибку для переменных тип которых явно не задан.
*07:30 по сути ? это сокращение  тип | undefined
*09:00 проверка типов
*10:35 проверка что переменная это массив
*11:00 если функция ничего не возвращает нужно поставить void
>>>3. Interfaces and Types
*02:30 отличия типоф от интерфейсов. Интерфейс наследуется при помщи extend а тип при помощи &
*04:10 у интерфейсов можно добавлять новые свойства (расшитять) а типы нет. Потому рекомендуется в большинстве случаев использовать интерфейсы и типы в случаях подобным stringOrNumber или строковые типы
*05:20 использование cast когда type2 extend type1 можно a:type2 = b:type1 as type2
*06:30 например cast работе с html getElmetById('canvas') -- будет HTMLElement но можно сделать as HTMLCanvasElement
>>>4. Упражнение 1 - Интерфейсы
>>>5. Литеральные типы
>>>6. Классы
*1:00 чтобы убрать необходимость обязательно инициализировать свойства класса можно использовать strictPropertyInitialization  или добавиь ! после имени свойства
*03:40 свойства могут быть readonly
*05:20 extend и  super()
*07:30 protected
*08:10 если при переопределении функции наследуемого класса мы хотим добавить параметр, то нужно сделать его необязательным используя ?
*10:10 абстрактные классы
*11:35 имплементация
>>>7. Enums
*0:40 автоматически числа начиная 0, но можно зать своё значение в любом месте и следующее будет +1, если задать строкой, то следующий тоже нужно задать, можно и числом тогда всё стабилизируется
*01:10 строковые
*01:40 гетерогенные. Пока не могу себе представить практической пользы от таких перечислений. Хотя, это просто у него пример плохой, предположительно можно организовать что-то вроде груп.
*02:00 расчетные могут быть только числовыми, чем вызвано такое ограничение мне пока не совсем понятно. Ещё помню, что в курсе по node говорилось что результат функции должен быт известен на момент компиляции, это не так!!! Возможно автор имел в виду константные enum но для них любые функции дают ошибки.
*03:10 использование печесления как объект
*03:40 обратный маппинг. в виде строки;
*04:30 в рантайме перечисление представляется в виде довольно сложной функции, но с константными всё намного проще
*05:50 тип never. Пример использования в swich, для избежания возможности упустить варианты в case
8. Generics
*01:10 оказывается до версии 1.18 (released 2022-03-15) в go не было нормальной поддержки generics (дженериков) (сейчас 05.04.2022 меньше чем месяц как появились :)
*03:30 в дженериках можно передавать несколько типов
*04:20 классы с Generics
*05:00 extend
>>>9. Манипуляции с типами
*довольно мутная тема, а с мутной головой вообще
*0:30 с помощью keyof можно получить union тип из ключей другого типа
*1:30 с помощью T = ReturnType<typeof f> где f это функция можно получить тип обекта возвращаемого функцией
*02:40 получение типа модержимого массива type Person = typeof MyArray[number] Если в массиве несколько элементов то будет union тип
*04:00 используя extend можно работать с типом как с условием Из примера вообще не понял как это использовать на практике. https://frontend-stuff.com/blog/conditional-types/#%D0%BD%D0%BE%D0%B2%D1%8B%D0%B5-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-conditional-types Здесь немного прояснилось, но пока всё равно мутно.
*06:40 неограниченное число ключей и значений
*07:20 мапить один тип на другой
*08:20 литеральный тип в стиле `hi ${name}`

4. Модули, контроллеры и провайдеры
>>>1. Обзор структуры проекта
*0:00 краткое описание tsconfig
*01:50 дополнительные параметры strict
*05:10 описание зависимостей
*06:40 описание скриптов
*09:20 замена eslint на ts-lint Я пока решил остаться на es, но для корректной работы пришлось поставить более новый шторм.
>>>2. Введение в модули
>>>3. Деление на модули
*02:25 создаем основные модули
*02:30 создаем модуль авторизации nest g module auth
*всего сдеали 4 модуля
>>>4. Создание моделей
*0:50 модель продукта
* nest g class product/product.model --no-spec
*1:30 --no-spec при создании модели указывает что не нужно создавать файл с тестами
*05:00 пример использования "06:40 неограниченное число ключей и значений"
*06:00 авторизация и отзывы
*08:00 страница (здесь есть enum)
>>>5. Введение в контроллеры
*0:50 установка глобального префикса для всего приложения app.setGlobalPrefix('api')
*02:50 в методе с декоратором Get мы можем возвращать обекты и они преобразуются в json
*03:10 разбор декораторов аргументов
*05:00 визуальная схема @Params @Query @Headers @Body
*05:20 дополнительные фичи контроллеров
*06:40 если использовать @Redirect могут появиться проблемы c cors
*07:10 можно возвращать Promise и Observable, nest сам это разрулит
*07:40 @Res response
>>>6. Создание контроллеров
*0:10 добавляем глобальный префикс в файле main.ts app.setGlobalPrefix('api'). Теперь все запросы в url должны будут иметь /api
*0:30 контроллер для модуля авторизации nest g controller auth
*3:30 когда мы делаем post, но при этом не происходит ни каких изминений (например при логине), то лучьше чтоб такой запрос возвращал не 201 а 200 @HttpCode(200)
*3:50 dto для auth Мы не берём из модели т.к. твм пароль захэширован, а здесь открытый
*05:00 извлекаем body
*05:30 контроллер для product
*07:00 для добавления нового продукта в качестве dto, нам практически подходит модель, но без _id.  В ts есть функция Omit которая создаст dto без указаных полей. Обратная ей ф-я Pick.
*08:10 получение продукта, get
*08:50 удаление и обновление продукта
*09:00 часто для удаления и обновления тоже используют post, но по фэншую лучьше patch и delete
*10:40 пойск продукта, для этого нужна dto
*12:15 контроллер review (обзор)
*14:00 запрос для получения отзывов о продукте
*15:05 top-page контроллер
>>>7. Введение в провайдеры
*00:00 провайдер это класс (сервис) либо значение либо фабрика которые с помощью nest внедряются в другие сервисы как зависимости
*00:45 декоратор @Injectable указывает что обект можно использовать как провайдер, тогда в @Module можно добавить в providers и в контроллере добавить его в конструктор
*если мы не вставили в providers то тоже можно использовать, но нужно экспорт/импорт 
*01:45 циклические зависимоти. Есть возможность это разрулить, но в целом наличие циклических зависимостей может указывать на недостаточно продуманную архитектуру
*2:15 типы провайдеров
*03:00 провайдер useClass используется в большинстве случаев и в этом случае можно использовать сокращенную запись в блоке providers
*03:45 useValue может использоватться в тестах взамен реального класса либо когда нужна общая для всех константа
*05:15 useFactory если нужны дополнительные настройки в зависимости от конфигурации
*06:10 useExisting если нужно уже существующей зависимости дать другое имя, пока хз зачем
*06:25 есть три scope типа
*06:30 default -- синглтон
*07:30 request -- новый для каждого запроса, а потом в мусор
*08:30 transient -- всегда новый

5. Работа с базой данных
>>>1. Работа с переменными окружения
*0:15 у nest есть модуль для работы с .env @nestjs/cnfig   
*01:00 добавляем модуль config в app.module.ts Обсуждение forRoot() и forFeature()
*01:30 по умолчанию берёт .env из корня
*02:00 заполняем .env
*его пример использования почему-то бил ошибку, но дальше работает, потому пока не стал вникать
>>>2. Подготовка окружения
*ставим docker контейнер с mongo
>>>3. Подключение Mongo
*помимо mongoos автор ставил зависимости typegoose nestjs-typegoos и что-то ещё, но на данный момент это устарело и не нужно т.к. mongoos уже сам поддерживает типизацию. Я поставил mongoos м @nestjs/mongoos. Пока работа с ними очень похожа на библиотеки которые использует автор
*03:30 подключаем модуль для работы с mongo. Если хотим брать параметры из .env то нужно использова forRootAsync
*04:40 используем useFactory
*06:50 создаём функцию getMongoConfig

>>>4. Подключение моделей
*т.к. у авторы устаревшие библиотеки я буду делать основываясь на https://www.youtube.com/watch?v=hvbIGDlrGJk
*0:30 подключаем модели как forFuture
*01:30 делаем модель auth
*02:00 можно создавать timestamp для информации о создании обновлении сущьности
*03:30 пример как можно поступисть когда нужно сделать extend от нескольких классов
*05:40 делаем модель product
*07:30 массивы нужно явно указывать в @prop() type: () => []
*09:40 отключаем создание индекса
*10:10 делаем модель reviev
*11:30 делаем модель top-pages тут есть enum
*для многих классов были небольшие переделки в плане выноса обектов в отдельные классы
*
>>>>Setup MongoDB With Nest.js | Simple + Scaleable https://www.youtube.com/watch?v=hvbIGDlrGJk
*шторм довольно сильно тупит при подсказках для mongoose
*1:10 настройка MongooseModule forRoot (я указал demo и все прошло без ошибок, похоже что база создалась автоматически, НЕТ ЭТО НЕ ТАК)
*1:45 создаем схему (модель)
*2:40 декоратор @Shema
*3:00 для каждого свойсва добавляем декоратор @Prop
*3:25 информируем mongoose о массиве строк @Prop([String])
*3:50 создаем export const UserSchema = SchemaFactory.createForClass(User)
*04:05 создаём новый тип используя union (объеденение) нашей модели User и Documenеt. Нужно быть внимательным чтобы Documenеt был от mongoose  UserDocument
*04:20 созаем модуль для созданной нами схемы. Мне кажется что порядок действий автора несколько запутанный. И вообще для новичка наверно лучьше создавать все элементы используя команды nest
*05:25 настраиваем схему для модуля
*05:30 свойство name есть у любого класса
*06:00 создаем репозиторий. Он @Injectable. В его конструкторе используем декоратар @InjectModel  @InjectModel(User.name) private userModel: Model<UserDocument>
*UserRepositry важно не забывать его включить providers
*07:45 если хотим чтобы название коллекции в mongoDB отличалось от названия класса @Shema({collection: 'colname'})
*08:10 создаем методы для работы с данными
*08:30 ичпользование FilterQuery
*09:00 метод find
*10:10 метод create
*10:55 обновление записи. Partial прикольная штука от ts, по сути для подмножества свойств объекта
*12:10 автор советует что основные операции можно закинуть в абстрактный класс
*12:10 создаем сервис
*13:40 контроллер
*14:50 DTO CreateUser
*15:56 DTO UpdateUser
*15:50 не забываем что нужно указывать зависимости в user.module контроллер в controllers и сервер и рекозиторий в providers
*19:20 метод findOneAndUpdate по умолчанию возваращает старый объект, для нового нужно добавить доп. параметр {new: true}
*
>>>Мои действия (Тут уже что-то сделал раньше, но постараюсь описать, а может и переделаю)
*начинаем с модуля auth
*Добавляем в AuthModel декораторы @Schema() и @Prop(), кроме того для поля email @Prop({ unique: true })
*делаем схему модели исползуя ShemaFactory
*делаем union модэли и типа Document
*теперь нужно это дело замутить репозиторий.  Для этого использую команду nest g provider auth/auth.repository
*в репозиторий добавляю конструктор constructor(@InjectModel(AuthModel.name) private authModel: Model<AuthModelDocument>)
*ну пожалуй для начала я хочу CRUD. Это пока только для теста, потом лишнее уберется.
*в create передаем AuthModel
*одного пока будем искать только по email, так что наверно можно обойтись и без фильтров 
*делаю ещё findAll без параметров
*теперь нужно этот функционал перенести в сервис
*опятьже начнем с create в идеале нужно будет пароль хэшировать но это позже, ну и не забвть про коснструктор
*с осталным просто вызываем соответсвующие функции из AuthRepository
*дальше контроллер. И здесь тоже конструктор, но уже с сервисом
*для начала просто чтоб потестим
*сразу проблемка, не сохраняетя пароль, потому что модели 'passwordHash', чтож значит всётаки нужно dto
*в typegoos для id полей нужно наследоваться от base или делать подобные хитрости (>>>4. Подключение моделей ~3:00) в современном mongoose для этого достаточно декоратора @Shema
*для отметок времени тоже используется параметр этого декоратора timestams: true
*вообще у него много параметров, как и у prop нужно будет в них разобраться, но позже, боевой проэт пока всеравно на oracle будет
*ну чтож, вообщем-то модуль ещё далеко не завершён, но пойду пока вместе с автором курса и сделаю все схемы/модели
*5:35 переходим к products
*в typegoose для пассива в props нужно дополнительно об этом указывать, в mongoose нет
*я когда тестировал забыл для полей вложенного типа указать поля как @Prop но всё прошло нормально
*что-то он про индекс и _id:false рассказал, я попробовал, но пока не понял -- то-ли не работает, то-ли я не так понял
*добавляем ProductModelDocument и ProductModelSchema
*в модуле добавляем импорт схемы
*10:00 переходим к review (тут все просто)
*11:25 переходим к top-page
*12:50 делаем @prop для enum, в typegoose нужно чё-то добалять
*т.к. auth у меня доработан аж до контроллера, то опять опробую на нём 
*@Prop без доп. параметров. Спокойно работает. Для цифрового в базу идет просто цифра, для текстового текст а для смешенного не компилируется.
*14:00 hh и advantages выносим в отдельный класс
*не забываем про схему, тип и импорт в файле модуля
*16:45 в результате при запуске должны быть проинициализированы все (в данном случае 4) MongooseModule

>>>5. Сервис отзывов
*создаем сервис  используя команду nest
*начинаем с создания (create)
*3:15 добавляем в модель поле связь с продуктом типа Types.ObjectId
*4:00 создаем DTO
*я делаю не так как автор курса
*создади репозиторий как provider
*вначале в репозитории параметром для create я решил взять Partial<ReviewModel>, затем передумал в сторону CreateDto, но все-же пока есть сомнения в этом месте
*затем реализуем это в сервисе и в контроллере (вначале создав их)
*я ещё пробовал в возвращаемое значение ставить  Partial<ReviewModelDocument>, внешне вроде разницы нет, но как правильно. Если смотреть на исходный код и документации то вроде Document. Или вообще забить, во всех примерах оставляют это автомату
*07:30 перешли к удалению
*08:50 поиск по productId
*11:00 теперь контроллер
*13:30 при удалении может быть нужно вызвать ошибку а её текст нужно держать в отдельной константе, только не забыть сделать для неё export
*пока при попытке удалить отсутвующий обект работает не так как ожидалось, но автор блин не тестит сразу и потому не понятно у меня чё-то не так или просто нужно иначе. АААТ ЖЕЖ БЛИН. А await перед промисом...
*работает, только прекрасно работает и без exec() в репозитории, зачем автор на нем настаивал. Либо от того что у меня больше шагов либо у него более старая версия и там таки надо, либо по старой памяти из совсем старых версий.
*ага, в документации сказано, что без exec() запросы mongoose возвращают не полноценные промисы, но даже хоть результат по функциональноси будет одинаков, лучьше всёже с ним т.к. "because that gives you better stack traces."